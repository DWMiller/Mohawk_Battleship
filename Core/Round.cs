using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using System.Diagnostics;
using MBC.Core.Accolades;
using MBC.Core.Events;

namespace MBC.Core
{
    /// <summary>
    /// A delegate defining a method to invoke with a RoundEvent.
    /// </summary>
    /// <param name="ev">The Event.</param>
    public delegate void MBCRoundEventHandler(RoundEvent ev);

    /// <summary>
    /// A Round class is the base class for a battleship round that processes game logic based on
    /// decisions made by controllers. A Round can support any number of Controller objects.<br /><br />
    /// In each Round, the following rules apply and are enforced, not overridable by any derived Round class:
    /// <list type="bullet">
    /// <item>Controllers must not overlap their ships.</item>
    /// <item>Controllers must return from any of their called methods within the game time limit.</item>
    /// </list>
    /// If any of the above rules are broken, the controller loses the Round.
    /// </summary>
    public abstract class Round
    {
        /// <summary>
        /// The Events generated and accumulated by this Round.
        /// </summary>
        protected List<RoundEvent> Events { get; set; }

        /// <summary>
        /// The AccoladeGenerator that generates and adds Accolade objects to this Round.
        /// </summary>
        protected AccoladeGenerator accoladeGenerator;

        /// <summary>
        /// A List of Accolade objects that have been added.
        /// </summary>
        protected List<Accolade> Accolades { get; set; }

        /// <summary>
        /// A List of Controller objects that have not lost.
        /// </summary>
        protected List<Controller> RemainingControllers { get; set; }

        /// <summary>
        /// A List of Controller objects that are involved in this Round.
        /// </summary>
        protected List<Controller> Controllers { get; set; }

        /// <summary>
        /// The ControllerID of the Controller that plays first.
        /// </summary>
        protected ControllerID CurrentTurnID { get; set; }

        /// <summary>
        /// The current game state of this Round.
        /// </summary>
        private State currentState;

        /// <summary>
        /// The MatchInfo object that contains properties that dictate how this Round behaves.
        /// </summary>
        private MatchInfo matchInfo;

        /// <summary>
        /// Invoked when an event has been generated by this Round.
        /// </summary>
        public event MBCRoundEventHandler EventCreated;

        /// <summary>
        /// Constructs a Round with the given Player objects.
        /// </summary>
        /// <param name="inputControllers">A variable number of controllers that are involved in this Round.</param>
        /// <param name="matchInfo">Information about the match that determines Round behaviour.</param>
        public Round(MatchInfo matchInfo, params Controller[] inputControllers)
        {
            Accolades = new List<Accolade>();
            Events = new List<RoundEvent>();
            Controllers = new List<Controller>();
            RemainingControllers = new List<Controller>();
            accoladeGenerator = new AccoladeGenerator(this);

            //Set the state to Begin.
            currentState = State.Begin;

            //Monitor events created.
            EventCreated += AddEvent;

            this.matchInfo = matchInfo;

            //Populate the Controller and RemainingController lists.
            foreach (var controller in inputControllers)
            {
                Controllers.Add(controller);
                RemainingControllers.Add(controller);
            }
        }

        /// <summary>
        /// Invokes the controller's NewRound method and constructs new ShotList objects for each Player. Picks
        /// a random Player from the Player List to start the Round off. Sets the State of this Round to
        /// ShipPlacement. Fires the RoundBeginEvent.<br />
        /// The base class's implementation for beginning a round is standard.
        /// </summary>
        protected virtual void Begin()
        {
            MakeEvent(new RoundBeginEvent(this));

            for(var i = 0; i < Controllers.Count; i++) {
                try
                {
                    Controllers[i].NewRound(i);
                }
                catch (ControllerTimeoutException ex)
                {
                    MakeEvent(new ControllerTimeoutEvent(this, ex));
                }
            }

            var randomTurnChooser = new Random();
            CurrentTurnID = randomTurnChooser.Next(Controllers.Count);

            currentState = State.ShipPlacement;
        }

        protected ControllerID NextRemaining()
        {
            for (var i = CurrentTurnID; i < Controllers.Count; i++)
            {
                if (RemainingControllers.Contains(Controllers[i]))
                {
                    return i;
                }
            }
            for (var i = 0; i < CurrentTurnID; i++)
            {
                if (RemainingControllers.Contains(Controllers[i]))
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Determines if the ships associated with the given Entity are placed, and do not conflict with each other.
        /// </summary>
        /// <param name="controller">The Entity ships to check</param>
        /// <returns>true if the ships related to the given Entity are valid, false otherwise.</returns>
        protected bool ControllerShipsValid(Controller controller)
        {
            return controller.Ships != null && controller.Ships.ShipsPlaced && controller.Ships.GetConflictingShips().Count == 0;
        }

        /// <summary>
        /// Essentially makes a Player lose this Round. Fires the ControllerLostEvent. Removes the given
        /// Player from the remaining Player objects in this Round. Switches the turn to the next Player.
        /// </summary>
        /// <param name="loser">The loser.</param>
        protected virtual void PlayerLose(Controller loser)
        {
            MakeEvent(new ControllerLostEvent(loser, this));
            try
            {
                loser.RoundLost();
            }
            catch (ControllerTimeoutException ex)
            {
                MakeEvent(new ControllerTimeoutEvent(this, ex));
            }
            RemainingControllers.Remove(loser);
        }

        /// <summary>
        /// Switches the turn from the current Player to the next Player. The current Player must exist in the
        /// remaining Player list or this method will throw an exception.
        /// </summary>
        /// <exception cref="InvalidOperationException">The current player had been removed the existing player list before switching turns.</exception>
        protected void NextTurn()
        {
            CurrentTurnID = NextRemaining();
        }

        /// <summary>
        /// Invokes the Player Controller object's methods for ship placement. Switches the State of this Round to
        /// the Shooting State if all Player Controller objects have made valid ship placements. Removes a Player
        /// from the List of remaining Player objects if their Controller does not make valid Ship placements
        /// or they run out of time.<br/>
        /// The base class's implemented procedure for ship placement is standard.
        /// </summary>
        protected virtual void ShipPlacement()
        {
            foreach (var controller in RemainingControllers)
            {
                try
                {
                    controller.PlaceShips();
                    MakeEvent(new ControllerShipsPlacedEvent(controller, this, controller.Ships));

                    if (!ControllerShipsValid(controller))
                    {
                        PlayerLose(controller);
                    }
                }
                catch (ControllerTimeoutException ex)
                {
                    MakeEvent(new ControllerTimeoutEvent(this, ex));
                    PlayerLose(controller);
                }
            }
            currentState = State.Main;
        }

        public void AddAccolade(Accolade accolade)
        {
            Accolades.Add(accolade);
            MakeEvent(new RoundAccoladeEvent(this, accolade));
        }

        /// <summary>
        /// The main game logic method invoked during normal round play.
        /// </summary>
        protected abstract void Main();

        /// <summary>
        /// Ends the Round. Fires the RoundEndEvent. Sets the State of this Round to End. Removes all event
        /// listeners for this Round.
        /// </summary>
        public virtual void End()
        {
            currentState = State.End;
            MakeEvent(new RoundEndEvent(this));
            EventCreated = null;
        }

        /// <summary>
        /// Used to progress a Round. Returns a value indicating whether or not this Round can be
        /// progressed any further.
        /// </summary>
        /// <returns>true if the Round is in progress. false otherwise.</returns>
        public bool Progress()
        {
            switch (currentState)
            {
                case State.Begin:
                    Begin();
                    break;
                case State.ShipPlacement:
                    ShipPlacement();
                    break;
                case State.Main:
                    Main();
                    break;
            }
            return currentState != State.End;
        }

        public List<Controller> GetControllers()
        {
            return new List<Controller>(Controllers);
        }

        public Controller ControllerFromID(ControllerID id)
        {
            return Controllers[id];
        }

        /// <summary>
        /// Gets the current State of this Round.
        /// </summary>
        public State CurrentState
        {
            get
            {
                return currentState;
            }
        }

        /// <summary>
        /// Gets the MatchInfo associated with this Round.
        /// </summary>
        public MatchInfo MatchInfo
        {
            get
            {
                return MatchInfo;
            }
        }

        public int RemainingCount
        {
            get
            {
                return RemainingControllers.Count;
            }
        }

        public int ControllerCount
        {
            get
            {
                return Controllers.Count;
            }
        }

        /// <summary>
        /// Invokes all event listeners on the RoundEvent event in this Round with the given RoundEvent object.
        /// </summary>
        /// <param name="ev">The RoundEvent to pass to the event listeners.</param>
        protected void MakeEvent(RoundEvent ev)
        {
            EventCreated(ev);
        }
        /// <summary>
        /// Adds a RoundEvent to the list of RoundEvent objects in this Round. This method will be subscribed to the
        /// RoundEvent event in this class.
        /// </summary>
        /// <param name="ev">The Event to add.</param>
        private void AddEvent(RoundEvent ev)
        {
            Events.Add(ev);
        }

        /// <summary>
        /// Identifies the time in the game this Round is in.
        /// </summary>
        public enum State
        {
            /// <summary>
            /// The Round is beginning.
            /// </summary>
            Begin,

            /// <summary>
            /// The Controller objects in the Round are to make their ship placements.
            /// </summary>
            ShipPlacement,

            /// <summary>
            /// The Round is progressing through the main game logic.
            /// </summary>
            Main,

            /// <summary>
            /// The Round has ended.
            /// </summary>
            End
        }

    }
}
