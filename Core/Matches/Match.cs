using MBC.Core.Events;
using MBC.Core.Rounds;
using MBC.Core.Util;
using MBC.Shared;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace MBC.Core.Matches
{
    /// <summary>
    /// <para>
    /// A match is the basic requirement of a game, in this case, a battleship game. Each Match contains
    /// a number of <see cref="Round"/>s and <see cref="Register"/>s. The Match provides functions
    /// on starting, playing, stopping, and ending the progress of the game. Each Match provides
    /// <see cref="MatchControls"/> used for multi-threading.
    /// </para>
    /// </summary>
    /// <seealso cref="MatchBeginEvent"/>
    /// <seealso cref="MatchEndEvent"/>
    /// <seealso cref="MatchEvent"/>
    /// <seealso cref="Round"/>
    /// <seealso cref="Register"/>
    /// <seealso cref="MatchControls"/>
    public abstract class Match
    {
        /// <summary>
        /// The main base contructor that takes in a <paramref name="config"/>.
        /// </summary>
        /// <param name="config">The <see cref="Configuration"/> to use.</param>
        public Match(Configuration config)
        {
            this.config = config;
            info = new CMatchInfo(Config);
            Events = new EventIterator();
            this.rounds = RoundIterator.CreateRoundIteratorFor(this);
        }

        /// <summary>
        /// Empty constructor used for serialization.
        /// </summary>
        protected Match()
        {
        }

        /// <summary>
        /// Invoked whenever an <see cref="Event"/> has been generated.
        /// </summary>
        public event MBCEventHandler Event;

        /// <summary>
        /// The <see cref="Configuration"/> used to determine game behaviour.
        /// </summary>
        private Configuration config;

        /// <summary>
        /// Gets the <see cref="Configuration"/> used to determine game behaviour.
        /// </summary>
        public Configuration Config
        {
            get
            {
                return config;
            }
        }

        /// <summary>
        /// Gets the <see cref="MatchControls"/> that handle multi-threading and automatic progression.
        /// </summary>
        [XmlIgnore]
        public MatchControls Controls
        {
            get;
            private set;
        }

        /// <summary>
        /// The <see cref="MatchInfo"/> set.
        /// </summary>
        private MatchInfo info;

        /// <summary>
        /// Gets the <see cref="MatchInfo"/> set.
        /// </summary>
        public MatchInfo Info
        {
            get
            {
                return info;
            }
        }

        /// <summary>
        /// The <see cref="Register"/>s created.
        /// </summary>
        /// <seealso cref="Register"/>
        protected List<Register> registers;

        /// <summary>
        /// Gets the <see cref="Register"/>s created.
        /// </summary>
        public List<Register> Registers
        {
            get
            {
                return registers;
            }
        }

        /// <summary>
        /// The <see cref="RoundIterator"/> containing the <see cref="Round"/>s.
        /// </summary>
        private RoundIterator rounds;

        /// <summary>
        /// Gets the <see cref="RoundIterator"/> containing the <see cref="Round"/>s.
        /// </summary>
        public RoundIterator Rounds
        {
            get
            {
                return rounds;
            }
        }

        /// <summary>
        /// Gets or sets the <see cref="Event"/>s that have been generated by this <see cref="Match"/>.
        /// </summary>
        private EventIterator Events
        {
            get;
            set;
        }

        /// <summary>
        /// <see cref="MatchControls.Stop()"/>s the match, ends the currently running <see cref="Round"/>, creates
        /// a <see cref="MatchEndEvent"/>, and prevents further progression of the match by setting the
        /// <see cref="RoundIterator.TargetRounds"/> to the current number of <see cref="Round"/>s.
        /// </summary>
        /// <seealso cref="MatchEvent"/>
        /// <seealso cref="RoundIterator"/>
        public void End()
        {
            Controls.Stop();
            Rounds.CurrentRound.End();
            MakeEvent(new MatchEndEvent());
            Rounds.TargetRounds = Rounds.RoundList.Count;
        }

        /// <summary>
        /// Saves the current progress of this <see cref="Match"/> to a file. All generated <see cref="Event"/>s
        /// and <see cref="Register"/>s are saved for later use. Match-specific <see cref="Configuration"/>
        /// settings are also saved to this file.
        /// </summary>
        /// <param name="fileName">A string containing the path of the file to save the XML file.</param>
        public void SaveToFile(string fileName)
        {
            var serializer = new XmlSerializer(typeof(Match), new Type[] {typeof(ControlledMatch), typeof(CMatchInfo)});
            var saveDir = Configuration.Global.GetValue<string>("app_data_root") + "matches\\";
            if (!Directory.Exists(saveDir))
            {
                Directory.CreateDirectory(saveDir);
            }
            var writer = new StreamWriter(saveDir + fileName);
            serializer.Serialize(writer, this);
            writer.Close();
        }

        /// <summary>
        /// Steps this <see cref="Match"/> backward by one event.
        /// </summary>
        /// <returns>True if this <see cref="Match"/> can still step backward.</returns>
        public bool StepBackward()
        {
            if (Rounds.CurrentRound.StepBackward() && Rounds.PrevRound())
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// Steps this <see cref="Match"/> forward by one event.
        /// </summary>
        /// <returns>True if this <see cref="Match"/> can still step forward.</returns>
        public bool StepForward()
        {
            if (Rounds.CurrentRound.StepForward() && Rounds.NextRound())
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// Creates a new <see cref="Round"/> for this <see cref="Match"/>.
        /// </summary>
        /// <returns></returns>
        internal abstract Round CreateNewRound();

        /// <summary>
        /// Used to send a generated <see cref="Event"/> to any listeners on <see cref="Match.Event"/>.
        /// </summary>
        /// <param name="ev">The <see cref="Event"/> generated in this <see cref="Match"/>.</param>
        /// <param name="backward">True if the event was invoked backwards.</param>
        internal void RoundEventGenerated(Event ev, bool backward)
        {
            if (Event != null)
            {
                Event(ev, backward);
            }
        }

        /// <summary>
        /// Generates a <see cref="Match"/>-specific <see cref="Event"/>.
        /// </summary>
        /// <param name="ev">The <see cref="Event"/> generated.</param>
        private void MakeEvent(Event ev)
        {
            Events.AddEvent(ev);
            if (Event != null)
            {
                Event(ev, false);
            }
        }
    }
}